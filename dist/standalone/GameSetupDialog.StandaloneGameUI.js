"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(window["webpackChunk_cdot_xanado"] = window["webpackChunk_cdot_xanado"] || []).push([["GameSetupDialog"],{

/***/ "./src/browser/Dialog.js":
/*!*******************************!*\
  !*** ./src/browser/Dialog.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Dialog\": () => (/* binding */ Dialog)\n/* harmony export */ });\n/* provided dependency */ var $ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\r\n  License MIT. See README.md at the root of this distribution for full copyright\r\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\r\n/* eslint-env browser, jquery */\r\n\r\n/* global Platform */\r\n\r\n/**\r\n * Base class of modal dialogs with demand-loadable HTML and a submit\r\n * button.\r\n *\r\n * HTML is loaded on demand from the html directory, based in the `id`\r\n * of the dialog (or the `html` option.\r\n *\r\n * In the HTML, any input or select that has a \"name\" attribute will\r\n * be used to populate a structure representing the dialog data.\r\n *\r\n * If a `postAction` URL option is set, this structure will be posted to the\r\n * URL and the result passed to an optional `postResult` function.\r\n *\r\n * Alternatively (or additionally), the `onSubmit` option can be set to\r\n * a function that will be called with `this` when the submit button\r\n * is pressed, *before* the `postAction` is sent.\r\n */\r\nclass Dialog {\r\n\r\n  /**\r\n   * Construct the named dialog, demand-loading the HTML as\r\n   * necessary. Do not use this - use {@linkcode Dialog#open|open()}\r\n   * instead.\r\n   * @param {string} id the dialog name\r\n   * @param {object} options options\r\n   * @param {string?} options.html optional name of HTML file to\r\n   * load, defaults to the id of the dialog\r\n   * @param {string?} options.postAction AJAX call name. If defined,\r\n   * the dialog fields will be posted here on close.\r\n   * @param {function?} options.postResult passed result\r\n   * of postAction AJAX call. Does nothing unless `postAction` is also\r\n   * defined.\r\n   * @param {function?} options.onSubmit Passed this, can be used without\r\n   * postAction.\r\n   * @param {function} options.error error function, passed jqXHR\r\n   */\r\n  constructor(id, options) {\r\n    /**\r\n     * Identifier for this dialog\r\n     */\r\n    this.id = id;\r\n\r\n    /**\r\n     * Cache of settings\r\n     * @member {object}\r\n     */\r\n    this.options = options;\r\n\r\n    /**\r\n     * Cache of jQuery object\r\n     * @member {jQuery}\r\n     * @private\r\n     */\r\n    this.$dlg = $(`#${id}`);\r\n\r\n    let promise;\r\n    if (this.$dlg.length === 0) {\r\n      // HTML is not already present; load it asynchronously.\r\n      promise = $.get(Platform.getFilePath(\r\n        `html/${options.html || id}.html`))\r\n      .then(html_code => {\r\n        $(\"body\").append(\r\n          $(document.createElement(\"div\"))\r\n          .attr(\"id\", id)\r\n          .addClass(\"dialog\")\r\n          .html(html_code));\r\n        this.$dlg = $(`#${id}`);\r\n      });\r\n    } else\r\n      promise = Promise.resolve();\r\n\r\n    promise\r\n    .then(() => this.$dlg.dialog({\r\n      title: options.title,\r\n      width: 'auto',\r\n      minWidth: 400,\r\n      modal: true,\r\n      open: () => {\r\n        if (this.$dlg.data(\"dialog_created\"))\r\n          this.openDialog();\r\n        else {\r\n          this.$dlg.data(\"dialog_created\", true);\r\n          this.createDialog()\r\n          .then(() => this.openDialog());\r\n        }\r\n      }\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Handle dialog creation once the HTML has been loaded, mainly\r\n   * for associating handlers and loading background data. This is\r\n   * invoked on an `open` event rather than `create` so we can be\r\n   * sure all initialisation steps are complete before the dialog\r\n   * opens.\r\n   * Override in subclasses to attach handlers etc. Subclasses should\r\n   * return super.createDialog()\r\n   * @protected\r\n   */\r\n  createDialog() {\r\n    this.$dlg\r\n    .find(\"[data-i18n]\")\r\n    .i18n();\r\n\r\n    this.$dlg\r\n    .find(\"input[data-i18n-placeholder]\")\r\n    .each(function() {\r\n      $(this).attr(\"placeholder\", $.i18n(\r\n        $(this).data(\"i18n-placeholder\")));\r\n    });\r\n\r\n    this.$dlg\r\n    .find(\"label[data-image]\")\r\n    .each(function() {\r\n      $(this).css(\"background-image\",\r\n                  `url(\"${$(this).data('image')}\")`);\r\n    });\r\n\r\n    // Using tooltips with a selectmenu is tricky.\r\n    // Applying tooltip() to the select is useless, you have\r\n    // to apply it to the span that is inserted as next\r\n    // sibling after the select. However this span is not\r\n    // created until some indeterminate time in the future,\r\n    // and there is no event triggered.\r\n    //\r\n    // What we have to do is to wait until the selectmenus\r\n    // have (hopefully!) been created before creating the\r\n    // tooltips.\r\n    const self = this;\r\n    this.$dlg\r\n    .find('select')\r\n    .selectmenu()\r\n    .on(\"selectmenuchange\",\r\n        function() {\r\n          $(this).blur();\r\n          self.$dlg.data(\"this\").enableSubmit();\r\n        });\r\n\r\n    setTimeout(\r\n      () => this.$dlg\r\n      .find('select[data-i18n-tooltip] ~ .ui-selectmenu-button')\r\n      .tooltip({\r\n        items: \".ui-selectmenu-button\",\r\n        position: {\r\n          my: \"left+15 center\",\r\n          at: \"right center\",\r\n          within: \"body\"\r\n        },\r\n        content: function() {\r\n          return $.i18n(\r\n            $(this)\r\n            .prev()\r\n            .data('i18n-tooltip'));\r\n        }\r\n      }),\r\n      100);\r\n\r\n    this.$dlg.find(\".submit\")\r\n    .on(\"click\", () => this.submit());\r\n\r\n    this.enableSubmit();\r\n\r\n    console.debug(\"Created\", this.id);\r\n    return Promise.resolve();\r\n  }\r\n\r\n  /**\r\n   * Subclass to set any dynamic values from context.\r\n   * Superclass must be called BEFORE subclass code.\r\n   * @return {Promise} promise that resolves to undefined\r\n   */\r\n  openDialog() {\r\n    console.debug(\"Opening\", this.id);\r\n    this.$dlg.data(\"this\", this);\r\n    return Promise.resolve(this);\r\n  }\r\n\r\n  /**\r\n   * Validate fields to determine if submit can be enabled.\r\n   * Override in subclasses.\r\n   */\r\n  canSubmit() {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Enable submit if field values allow it.\r\n   * @protected\r\n   */\r\n  enableSubmit() {\r\n    this.$dlg.find(\".submit\").prop(\r\n      \"disabled\", !this.canSubmit());\r\n  }\r\n\r\n  /**\r\n   * Populate a structure mapping field names to values.\r\n   * @param {object} p optional hash of param values, so subclasses\r\n   * can handle non-input type data.\r\n   */\r\n  getFieldValues(p)  {\r\n    if (!p)\r\n      p = {};\r\n    this.$dlg\r\n    .find(\"input[name],select[name],textarea[name]\")\r\n    .each(function() {\r\n      let name = $(this).attr(\"name\");\r\n      let value;\r\n      if (this.type === \"checkbox\")\r\n        value = $(this).is(\":checked\") ? true : false;\r\n      else if (this.type === \"radio\") {\r\n        if (!$(this).is(\":checked\"))\r\n          return;\r\n        // Radio buttons are grouped by name, so use id\r\n        name = this.id;\r\n        value = true;\r\n      } else if (this.type === \"number\") {\r\n        value = parseInt($(this).val());\r\n        if (isNaN(value))\r\n          return;\r\n      } else // text, password, email, <select, <textarea\r\n        value = $(this).val() || $(this).text();\r\n      //console.debug(name,\"=\",value);\r\n      // Collect <input with the same name, and make arrays\r\n      if (typeof p[name] === \"undefined\")\r\n        p[name] = value;\r\n      else if (typeof p[name] === \"string\")\r\n        p[name] = [ p[name], value ];\r\n      else\r\n        p[name].push(value);\r\n    });\r\n\r\n    return p;\r\n  }\r\n\r\n  /**\r\n   * Handle submit button\r\n   * @param {object} vals optional hash of param values, so subclasses\r\n   * can handle non-input type data.\r\n   * @private\r\n   */\r\n  submit(vals) {\r\n    this.$dlg.dialog(\"close\");\r\n    vals = this.getFieldValues(vals);\r\n\r\n    if (this.options.onSubmit)\r\n      this.options.onSubmit(this, vals);\r\n\r\n    if (!this.options.postAction)\r\n      return;\r\n\r\n    // Note that password fields are sent as plain text. This is\r\n    // not a problem so long as the comms are protected by HTTPS,\r\n    // and is simpler/cleaner than using BasicAuth.\r\n    // Some day we may implement OpenAuth, but there's no hurry.\r\n    $.ajax({\r\n      url: this.options.postAction,\r\n      type: \"POST\",\r\n      contentType: \"application/json\",\r\n      data: JSON.stringify(vals)\r\n    })\r\n    .then(data => {\r\n      if (typeof this.options.postResult === \"function\")\r\n        this.options.postResult(data);\r\n    })\r\n    .catch(jqXHR => {\r\n      // Note that the console sees an XML parsing error on a 401\r\n      // response to /signin, due to the response body containing a\r\n      // non-XML string (\"Unauthorized\"). It would be nice to catch\r\n      // this gracefully and suppress the console print, but I can't\r\n      // find any way to do that.\r\n      if (typeof this.options.error === \"function\")\r\n        this.options.error(jqXHR);\r\n      else\r\n        console.error(jqXHR.responseText);\r\n    });\r\n  }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/browser/Dialog.js?");

/***/ }),

/***/ "./src/browser/GameSetupDialog.js":
/*!****************************************!*\
  !*** ./src/browser/GameSetupDialog.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GameSetupDialog\": () => (/* binding */ GameSetupDialog)\n/* harmony export */ });\n/* harmony import */ var _game_Game_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game.js */ \"./src/game/Game.js\");\n/* harmony import */ var _Dialog_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Dialog.js */ \"./src/browser/Dialog.js\");\n/* provided dependency */ var $ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\r\n  License MIT. See README.md at the root of this distribution for full copyright\r\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\r\n/* eslint-env browser, jquery */\r\n\r\n\r\n\r\n\r\n/**\r\n * Dialog for modifying game options.\r\n * @extends Dialog\r\n */\r\nclass GameSetupDialog extends _Dialog_js__WEBPACK_IMPORTED_MODULE_1__.Dialog {\r\n\r\n  // ordered types for <select>s in UI\r\n  static Penalty_types = [\r\n    _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.Penalty.PER_WORD, _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.Penalty.PER_TURN,\r\n    _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.Penalty.MISS, _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.Penalty.NONE\r\n  ];\r\n\r\n  static Timer_types = [\r\n    _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.Timer.NONE, _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.Timer.TURN, _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.Timer.GAME\r\n  ];\r\n\r\n  static WordCheck_types = [\r\n    _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.WordCheck.NONE, _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.WordCheck.AFTER, _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.WordCheck.REJECT\r\n  ];\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  canSubmit() {\r\n    console.debug(\"Validate edition\",\r\n                  this.$dlg.find(\"[name=edition]\").val(),\r\n                  \"play dictionary\",\r\n                  this.$dlg.find(\"[name=dictionary]\").val());\r\n    return (this.$dlg.find(\"[name=edition]\").val() !== 'none');\r\n  }\r\n\r\n  constructor(options) {\r\n    super(\"GameSetupDialog\", options);\r\n  }\r\n\r\n  showTimerFields() {\r\n    const type = this.$dlg.find(\"[name=timerType]\").val();\r\n    switch (type) {\r\n    default:\r\n      this.$dlg.find(\"[name=timeAllowed]\")\r\n      .parent().hide();\r\n      this.$dlg.find(\"[name=timePenalty]\")\r\n      .parent().hide();\r\n      break;\r\n    case _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.Timer.TURN:\r\n      this.$dlg.find(\"[name=timeAllowed]\")\r\n      .parent().show();\r\n      this.$dlg.find(\"[name=timePenalty]\")\r\n      .parent().hide();\r\n      break;\r\n    case _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.Timer.GAME:\r\n      this.$dlg.find(\"[name=timeAllowed]\")\r\n      .parent().show();\r\n      this.$dlg.find(\"[name=timePenalty]\")\r\n      .parent().show();\r\n      break;\r\n    }\r\n  }\r\n\r\n  showPenaltyFields() {\r\n    const type = this.$dlg.find(\"[name=challengePenalty]\").val();\r\n    switch (type) {\r\n    default:\r\n      this.$dlg.find(\"[name=penaltyPoints]\")\r\n      .parent().hide();\r\n      break;\r\n    case _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.Penalty.PER_TURN:\r\n    case _game_Game_js__WEBPACK_IMPORTED_MODULE_0__.Game.Penalty.PER_WORD:\r\n      this.$dlg.find(\"[name=penaltyPoints]\")\r\n      .parent().show();\r\n      break;\r\n    }\r\n  }\r\n\r\n  showFeedbackFields() {\r\n    const dic = this.$dlg.find(\"[name=dictionary]\").val();\r\n    this.$dlg.find(\"[name=wordCheck]\")\r\n    .parent().toggle(dic !== \"none\");\r\n  }\r\n\r\n  createDialog() {\r\n    function makeOptions(list, $sel) {\r\n      for (const p of list)\r\n        $sel.append(\r\n          `<option value=\"${p ? p : 'none'}\">${p ? $.i18n(p) : $.i18n(\"None\")}</option>`);\r\n    }\r\n    const $pen = this.$dlg.find(\"[name=challengePenalty]\");\r\n    makeOptions(GameSetupDialog.Penalty_types, $pen);\r\n    $pen.on(\"selectmenuchange\", () => this.showPenaltyFields());\r\n    this.showPenaltyFields();\r\n\r\n    const $tim = this.$dlg.find(\"[name=timerType]\");\r\n    makeOptions(GameSetupDialog.Timer_types, $tim);\r\n    $tim.on(\"selectmenuchange\", () => this.showTimerFields());\r\n    this.showTimerFields();\r\n\r\n    const $wc = this.$dlg.find(\"[name=wordCheck]\");\r\n    makeOptions(GameSetupDialog.WordCheck_types, $wc);\r\n\r\n    const ui = this.options.ui;\r\n    return Promise.all([\r\n      ui.getEditions()\r\n      .then(editions => {\r\n        const $eds = this.$dlg.find('[name=edition]');\r\n        editions.forEach(e => $eds.append(`<option>${e}</option>`));\r\n        if (ui.getSetting('edition'))\r\n          $eds.val(ui.getSetting('edition'));\r\n      }),\r\n      ui.getDictionaries()\r\n      .then(dictionaries => {\r\n        const $dics = this.$dlg.find('[name=dictionary]');\r\n        dictionaries\r\n        .forEach(d => $dics.append(`<option>${d}</option>`));\r\n        if (ui.getSetting('dictionary'))\r\n          $dics.val((ui.getSetting('dictionary')));\r\n        $dics.on(\"selectmenuchange\", () => this.showFeedbackFields());\r\n        this.showFeedbackFields();\r\n      })\r\n    ])\r\n    .then(() => super.createDialog());\r\n  }\r\n\r\n  openDialog() {\r\n    return super.openDialog()\r\n    .then(() => {\r\n      this.$dlg.find(\".dialog-row\").show();\r\n      const game = this.options.game;\r\n      if (game) {\r\n        // Some game options are only tweakable if there are no turns\r\n        // signed in the game. This is controlled by a \"noturns\" class on\r\n        // the dialog-row\r\n        if (game.turns.length > 0)\r\n          this.$dlg.find(\".noturns\").hide();\r\n\r\n        const $fields = this.$dlg.find('[name]');\r\n        $fields.each((i, el) => {\r\n          const field = $(el).attr(\"name\");\r\n          const val = game[field];\r\n          //console.debug(\"SET\",field,\"=\",game[field]);\r\n          if (el.tagName === \"INPUT\" && el.type === \"checkbox\") {\r\n            if (val)\r\n              $(el).attr(\"checked\", \"checked\");\r\n            else\r\n              $(el).removeAttr(\"checked\");\r\n          } else {\r\n            $(el).val(game[field]);\r\n            if (el.tagName === \"SELECT\")\r\n              $(el).selectmenu(\"refresh\");\r\n          }\r\n          return true;\r\n        });\r\n      }\r\n    }).then(() => super.openDialog());\r\n  }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/browser/GameSetupDialog.js?");

/***/ })

}]);