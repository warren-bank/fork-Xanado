{"version":3,"file":"standalone/findBestPlay.StandaloneGamesUI.js","mappings":"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","sources":["webpack://@warren-bank/scrabble/./src/game/findBestPlay.js"],"sourcesContent":["/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\r\n  License MIT. See README.md at the root of this distribution for full copyright\r\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\r\n/* eslint-env amd */\r\n\r\nimport { loadDictionary } from \"./loadDictionary.js\";\r\nimport { Edition } from \"./Edition.js\";\r\nimport { Tile } from \"./Tile.js\";\r\nimport { Move } from \"./Move.js\";\r\n\r\n/** @module */\r\n\r\n/**\r\n * Return a list of the letters that are in both arrays. Does\r\n * not handle blank!\r\n * @param {string[]} a array of letters\r\n * @param {string[]} b array of letters\r\n * @return {string[]} intersection of a and b\r\n * @private\r\n */\r\nfunction intersection(a, b) {\r\n  return a.filter(l => b.indexOf(l) >= 0);\r\n}\r\n\r\n/**\r\n * Dictionary being used to find words\r\n * @private\r\n */\r\nlet dictionary;\r\n\r\n/**\r\n * Edition being played.\r\n * @private\r\n */\r\nlet edition;\r\n\r\n/**\r\n * A matrix where each [col][row] square has two lists, one of\r\n * valid vertical chars and another of valid horizontal chars. The\r\n * [0] lists give the letters that are valid for forming a\r\n * vertical cross word, and the [1] lists give the letters valid\r\n * for creating a horizontal cross word.\r\n * @private\r\n */\r\nlet crossChecks;\r\n\r\n/**\r\n * Shortcut to the board in the game\r\n * @private\r\n */\r\nlet board;\r\n\r\n/**\r\n * The listener function. This takes either a play, or a string\r\n * describing progress. This allows the finder to run in a thread\r\n * and still report back via the main event loop.\r\n * @private\r\n */\r\nlet report;\r\n\r\n/**\r\n * Best score found so far when searching for a move.\r\n * @private\r\n*/\r\nlet bestScore = 0;\r\n\r\n/**\r\n * Unlike Appel and Jacobsen, who anchor plays on empty squares,\r\n * we anchor plays on a square with a tile that has an adjacent\r\n * (horizontal or vertical) non-empty square. This significantly\r\n * reduces the number of anchors that have to be evaluated.\r\n * @param {number} col the square to inspect\r\n * @param {number} row the square to inspect\r\n * @return {boolean} true if this square is a valid anchor\r\n * @private\r\n */\r\nfunction isAnchor(col, row) {\r\n  return !board.at(col, row).isEmpty()\r\n  && (col > 0 && board.at(col - 1, row).isEmpty()\r\n      || col < board.cols - 1 && board.at(col + 1, row).isEmpty()\r\n      || row > 0 && board.at(col, row - 1).isEmpty()\r\n      || row < board.rows - 1 && board.at(col, row + 1).isEmpty());\r\n}\r\n\r\n/**\r\n * Determine which letters can fit in each square and form a valid\r\n * horizontal or vertical cross word. This returns a matrix where\r\n * each [col][row] square has two lists, one of valid vertical\r\n * chars and another of valid horizontal chars. The [0] lists give\r\n * the letters that are valid for forming a vertical cross word,\r\n * and the [1] lists give the letters valid for creating a\r\n * horizontal cross word.  The indices are chosen such that the\r\n * cells can be indexed using the dcol parameter in the other\r\n * functions.\r\n * @param {string[]} available the set of available letters\r\n * @private\r\n */\r\nfunction computeCrossChecks(available) {\r\n  const xChecks = [];\r\n\r\n  for (let col = 0; col < board.cols; col++) {\r\n    const thisCol = [];\r\n    xChecks.push(thisCol);\r\n\r\n    for (let row = 0; row < board.rows; row++) {\r\n      const thisCell = [[], []];\r\n      thisCol[row] = thisCell;\r\n\r\n      if (board.at(col, row).tile) {\r\n        // The cell isn't empty, only this letter is valid.\r\n        thisCell[0].push(board.at(col, row).tile.letter);\r\n        thisCell[1].push(board.at(col, row).tile.letter);\r\n        continue;\r\n      }\r\n\r\n      // Find the words above and below\r\n      let wordAbove = \"\";\r\n      let r = row - 1;\r\n      while (r >= 0 && board.at(col, r).tile) {\r\n        wordAbove = board.at(col, r).tile.letter + wordAbove;\r\n        r--;\r\n      }\r\n\r\n      let wordBelow = \"\";\r\n      r = row + 1;\r\n      while (r < board.rows && board.at(col, r).tile) {\r\n        wordBelow += board.at(col, r).tile.letter;\r\n        r++;\r\n      }\r\n\r\n      // Find the words left and right\r\n      let wordLeft = \"\";\r\n      let c = col - 1;\r\n      while (c >= 0 && board.at(c, row).tile) {\r\n        wordLeft = board.at(c, row).tile.letter + wordLeft;\r\n        c--;\r\n      }\r\n\r\n      let wordRight = \"\";\r\n      c = col + 1;\r\n      while (c != board.cols && board.at(c, row).tile) {\r\n        wordRight += board.at(c, row).tile.letter;\r\n        c++;\r\n      }\r\n\r\n      // Find which (if any) letters form a valid cross word\r\n      for (let letter of available) {\r\n        const h = wordLeft + letter + wordRight;\r\n\r\n        // Is h a complete valid word, or just the letter\r\n        // on its tod?\r\n        const hIsWord = h.length === 1 || dictionary.hasWord(h);\r\n        // Is h a valid complete word, or a legal sub-sequence?\r\n        const hIsSeq = hIsWord || col > 0 && dictionary.hasSequence(h);\r\n\r\n        const v = wordAbove + letter + wordBelow;\r\n        const vIsWord = v.length === 1 || dictionary.hasWord(v);\r\n        const vIsSeq = vIsWord || row > 0 && dictionary.hasSequence(v);\r\n\r\n        if (hIsWord && vIsSeq)\r\n          // A down word is playable with this letter, and\r\n          // there's a valid down sequence involving the\r\n          // letter\r\n          thisCell[0].push(letter);\r\n\r\n        if (vIsWord && hIsSeq)\r\n          // An across word is playable with this letter, and\r\n          // there's a valid across sequence involving the\r\n          // letter\r\n          thisCell[1].push(letter);\r\n      }\r\n    }\r\n  }\r\n\r\n  crossChecks = xChecks;\r\n}\r\n\r\n/**\r\n * Given a position that can have a letter, recursively compute possible\r\n * word plays by extending down/across the board. For each word,\r\n * compute its point value, and update the best score\r\n * accordingly.\r\n *\r\n * @param {number} col index of the current position on the board. This\r\n * is the posiiton of the last character of the word constructed so far.\r\n * @param {number} row index of the current position on the board. This\r\n * is the posiiton of the last character of the word constructed so far.\r\n * @param {number} dcol 1 if the extension direction is across\r\n * @param {number} drow 1 if the extension direction is down\r\n * @param {Tile[]} rackTiles tiles remaining from the user's letter rack.\r\n * @param {number} tilesPlayed number of tiles from the rack already played\r\n * @param {LetterNode} dNode the current LetterNode\r\n * @param {Tile[]} wordSoFar the known letters terminating at the dNode.\r\n * @private\r\n */\r\nfunction forward(col, row,\r\n                 dcol, drow,\r\n                 rackTiles, tilesPlayed,\r\n                 dNode,\r\n                 wordSoFar) {\r\n\r\n  // Square we're hopefully extending into\r\n  const ecol = col + dcol;\r\n  const erow = row + drow;\r\n\r\n  //console.log(`forward '${wordSoFar}' ${col}:${dcol} ${row}:${drow} [${dNode.postLetters.join('')}]`);\r\n\r\n  // Tail recurse; report words as soon as we find them\r\n  // Are we sitting at the end of a scoring word?\r\n  if (dNode.isEndOfWord\r\n      && wordSoFar.length >= 2\r\n      && tilesPlayed > 0\r\n      && (ecol == board.cols || erow == board.rows\r\n          || !board.at(ecol, erow).tile)) {\r\n    const words = [];\r\n    const score =\r\n          board.scorePlay(col, row, dcol, drow,\r\n                               wordSoFar, words)\r\n          + edition.calculateBonus(tilesPlayed);\r\n\r\n    if (score > bestScore) {\r\n      bestScore = score;\r\n      //console.log(drow > 0 ? \"vertical\" : \"horizontal\")\r\n      report(new Move({\r\n        placements: wordSoFar.filter(\r\n          t => !board.at(t.col, t.row).tile),\r\n        words: words,\r\n        score: score\r\n      }));\r\n    }\r\n  }\r\n\r\n  let available; // list of letters that can be extended with\r\n  let playedTile = 0;\r\n\r\n  if (ecol < board.cols && erow < board.rows) {\r\n    // Do we have an empty cell we can extend into?\r\n    if (board.at(ecol, erow).isEmpty()) {\r\n      const haveBlank = rackTiles.find(l => l.isBlank);\r\n      const xc = crossChecks[ecol][erow][dcol];\r\n\r\n      available = intersection(\r\n        dNode.postLetters,\r\n        haveBlank ? xc : intersection(\r\n          rackTiles.map(t => t.letter), xc));\r\n      playedTile = 1;\r\n\r\n    } else\r\n      // Have pre-placed tile\r\n      available = [ board.at(ecol, erow).tile.letter ];\r\n  }\r\n  else // off the board\r\n    available = [];\r\n\r\n  for (let letter of available) {\r\n    let shrunkRack = rackTiles;\r\n    if (playedTile > 0) {\r\n      // Letter played from the rack\r\n      const rackTile = shrunkRack.find(l => l.letter === letter)\r\n            || shrunkRack.find(l => l.isBlank);\r\n      wordSoFar.push(\r\n        new Tile({letter:letter, isBlank:rackTile.isBlank,\r\n                  score:rackTile.score,\r\n                  // Note placement is not used in score computation\r\n                  col: ecol, row: erow}));\r\n      shrunkRack = shrunkRack.filter(t => t !== rackTile);\r\n    } else\r\n      wordSoFar.push(board.at(ecol, erow).tile);\r\n\r\n    for (let post of dNode.postNodes) {\r\n      if (post.letter === letter) {\r\n        forward(ecol, erow,\r\n                     dcol, drow,\r\n                     shrunkRack, tilesPlayed + playedTile,\r\n                     post,\r\n                     wordSoFar);\r\n      }\r\n    }\r\n\r\n    wordSoFar.pop();\r\n  }\r\n}\r\n\r\n/**\r\n * Given a position that may be part of a word, and the letters of\r\n * the word it may be part of, try to back up/left before extending\r\n * down/right.\r\n *\r\n * @param {number} col index of the current position on the board. This\r\n * is the posiiton of the last character of the word constructed so far.\r\n * @param {number} row index of the current position on the board. This\r\n * is the posiiton of the last character of the word constructed so far.\r\n * @param {number} dcol 1 if the extension direction is across\r\n * @param {number} drow 1 if the extension direction is down\r\n * @param {Tile[]} rackTiles tiles remaining from the user's letter rack.\r\n * @param {number} tilesPlayed number of tiles from the rack already played\r\n * @param {LetterNode} anchorNode the DictNode where we started backing up\r\n * @param {LetterNode} dNode the current LetterNode\r\n * @param {Tile[]} wordSoFar the known letters terminating at the dNode.\r\n * @private\r\n */\r\nfunction back(col, row,\r\n              dcol, drow,\r\n              rackTiles, tilesPlayed,\r\n              anchorNode, dNode,\r\n              wordSoFar) {\r\n\r\n  // Square we're hopefully extending into\r\n  const ecol = col - dcol;\r\n  const erow = row - drow;\r\n\r\n  let available; // the set of possible candidate letters\r\n  let playedTile = 0;\r\n\r\n  //console.log(`back '${wordSoFar}' ${col}:${dcol} ${row}:${drow} [${dNode.preLetters.join('')}]`);\r\n\r\n  // Do we have an adjacent empty cell we can back up into?\r\n  if (ecol >= 0 && erow >= 0) {\r\n    if (board.at(ecol, erow).isEmpty()) {\r\n      // Find common letters between the rack, cross checks, and\r\n      // dNode pre.\r\n      const haveBlank = rackTiles.find(l => l.isBlank);\r\n      const xc = crossChecks[ecol][erow][dcol];\r\n\r\n      available =\r\n      intersection(\r\n        dNode.preLetters,\r\n        haveBlank ? xc : intersection(\r\n          rackTiles.map(l => l.letter),  xc));\r\n      playedTile = 1;\r\n    } else\r\n      // Non-empty square, might be able to walk back through it\r\n      available = [ board.at(ecol, erow).tile.letter ];\r\n  }\r\n  else\r\n    // Off the board, nothing available for backing up\r\n    available = [];\r\n\r\n  // Head recurse; longer words are more likely to\r\n  // be high scoring, so want to find them first\r\n  for (let letter of available) {\r\n    let shrunkRack = rackTiles;\r\n    if (playedTile > 0) {\r\n      // Letter came from the rack\r\n      const tile = shrunkRack.find(l => l.letter === letter)\r\n            || shrunkRack.find(l => l.isBlank);\r\n      wordSoFar.unshift(\r\n        new Tile({\r\n          letter: letter, isBlank: tile.isBlank,\r\n          score: tile.score,\r\n          // Note placement is not used in score computation\r\n          col: ecol, row: erow\r\n        }));\r\n      shrunkRack = shrunkRack.filter(t => t !== tile);\r\n    } else\r\n      // Letter already on the board\r\n      wordSoFar.unshift(board.at(ecol, erow).tile);\r\n\r\n    for (let pre of dNode.preNodes) {\r\n      if (pre.letter === letter) {\r\n        back(ecol, erow,\r\n                  dcol, drow,\r\n                  shrunkRack, tilesPlayed + playedTile,\r\n                  anchorNode, pre,\r\n                  wordSoFar);\r\n      }\r\n    }\r\n\r\n    wordSoFar.shift();\r\n  }\r\n\r\n  // If this is the start of a word in the dictionary, and\r\n  // we're at the edge of the board or the prior cell is\r\n  // empty, then we have a valid word start.\r\n  if (dNode.preNodes.length == 0\r\n      && (erow < 0 || ecol < 0 || board.at(ecol, erow).isEmpty())) {\r\n    //console.log(`back word start ${ecol}:${dcol},${erow}:${drow}`);\r\n    // try extending down beyond the anchor, with the letters\r\n    // that we have determined comprise a valid rooted sequence.\r\n    forward(col + dcol * (wordSoFar.length - 1),\r\n                 row + drow * (wordSoFar.length - 1),\r\n                 dcol, drow,\r\n                 rackTiles, tilesPlayed,\r\n                 anchorNode,\r\n                 wordSoFar);\r\n  }\r\n}\r\n\r\n/**\r\n * Special case of the opening move. Find anagrams of the player's\r\n * rack, and find the highest scoring position for each possible word.\r\n * @param {Tile[]} rackTiles tiles on the rack\r\n * @private\r\n */\r\nfunction bestOpeningPlay(rackTiles) {\r\n  const ruck = rackTiles.map(l => l.letter ? l.letter : \" \").join(\"\");\r\n  const choices = dictionary.findAnagrams(ruck);\r\n  //console.debug(\"Choices\", choices);\r\n  // Random whether it is played across or down\r\n  const drow = Math.round(Math.random());\r\n  const dcol = (drow + 1) % 2;\r\n  const vertical = dcol === 0;\r\n  bestScore = 0;\r\n\r\n  for (const choice in choices) {\r\n    // Keep track of the rack and played letters\r\n    const placements = [];\r\n    let shrunkRack = rackTiles;\r\n    for (const c of choice.split(\"\")) {\r\n      const rackTile = shrunkRack.find(t => t.letter === c)\r\n            || shrunkRack.find(t => t.isBlank);\r\n      /* istanbul ignore next */\r\n      assert(rackTile,\r\n             \"Can't do this with the available tiles\");\r\n      placements.push(new Tile({\r\n        letter: c, isBlank: rackTile.isBlank,\r\n        score:rackTile.score\r\n        // Placement is fixed later\r\n      }));\r\n      shrunkRack = shrunkRack.filter(t => t !== rackTile);\r\n    }\r\n\r\n    // Slide the word over the middle to find the optimum\r\n    // position\r\n    const mid = vertical ? board.midcol : board.midrow;\r\n    for (let end = mid;\r\n         end < mid + choice.length;\r\n         end++) {\r\n\r\n      const col = vertical ? mid : end;\r\n      const row = vertical ? end : mid;\r\n      const score =\r\n            board.scorePlay(col, row, dcol, drow, placements)\r\n            + edition.calculateBonus(placements.length);\r\n\r\n      if (score > bestScore) {\r\n        //console.debug(\"Accepted\",choice,\"at\",end,\"for\",score);\r\n        bestScore = score;\r\n        // Fix the placement\r\n        for (let i = 0; i < placements.length; i++) {\r\n          const pos = end - placements.length + i + 1;\r\n          placements[i].col = dcol == 0 ? board.midcol : pos * dcol;\r\n          placements[i].row = drow == 0 ? board.midrow : pos * drow;\r\n        }\r\n        //console.log(drow > 0 ? \"vertical\" : \"horizontal\")\r\n        report(new Move({\r\n          placements: placements,\r\n          words: [{ word: choice, score: score }],\r\n          score: score\r\n        }));\r\n      } else {\r\n        //console.debug(\"Rejected\",choice,\"at\",end,\"for\",score);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Find the best play for the given rack. The results are reported\r\n * using the listener.\r\n * @param {Tile[]} rack rack of tiles to pick from\r\n * @private\r\n */\r\nfunction find(rack) {\r\n  // sort and reverse the rack to make sure high value letters come\r\n  // first and blanks come last. It's not going to make it\r\n  // any faster, but it will abort with a better result if\r\n  // it's going to time out.\r\n  const rackTiles = rack.sort((a, b) => {\r\n    return a.letter < b.letter ? -1  : a.score > b.score ? 1 : 0;\r\n  }).reverse();\r\n\r\n  report(\"Finding best play for rack \"\r\n              + rack.map(t => t.stringify()).join(\",\"));\r\n\r\n  report(`with dictionary ${dictionary.name}`);\r\n  report(`in edition ${edition.name}`);\r\n  report(\"on\\n\" + board.stringify());\r\n\r\n  //assert(dictionary instanceof Dictionary, \"Setup failure\");\r\n  assert(edition instanceof Edition, \"Setup failure\");\r\n\r\n  report(\"Starting findBestPlay computation for \"\r\n              + rackTiles.map(t => t.stringify()).join(\",\")\r\n              + \" on \" + board.stringify());\r\n  bestScore = 0;\r\n\r\n  // Has at least one anchor been explored? If there are\r\n  // no anchors, we need to compute an opening play\r\n  let anchored = false;\r\n  for (let col = 0; col < board.cols; col++) {\r\n    for (let row = 0; row < board.rows; row++) {\r\n      // An anchor is any square that has a tile and has an\r\n      // adjacent blank that can be extended into to form a word\r\n      if (isAnchor(col, row)) {\r\n        if (!anchored) {\r\n          // What letters can be used to form a valid cross\r\n          // word? The whole alphabet if the rack contains a\r\n          // blank, the rack otherwise.\r\n          const available = rackTiles.find(l => l.isBlank)\r\n                ? edition.alphabet\r\n                : (rackTiles.filter(t => !t.isBlank)\r\n                   .map(t => t.letter));\r\n          computeCrossChecks(available);\r\n          anchored = true;\r\n        }\r\n        const anchorTile = board.at(col, row).tile;\r\n        const roots = dictionary.getSequenceRoots(anchorTile.letter);\r\n        for (let anchorNode of roots) {\r\n          // Try and back up then forward through\r\n          // the dictionary to find longer sequences\r\n          // across\r\n          back(\r\n            col, row,\r\n            1, 0,\r\n            rackTiles, 0,\r\n            anchorNode, anchorNode,\r\n            [ anchorTile ]);\r\n\r\n          // down\r\n          back(\r\n            col, row,\r\n            0, 1,\r\n            rackTiles, 0,\r\n            anchorNode, anchorNode,\r\n            [ anchorTile ]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!anchored)\r\n    // No anchors, so this is an opening play.\r\n    bestOpeningPlay(rackTiles);\r\n}\r\n\r\n/**\r\n * Given a user's letter rack, compute the best possible move.\r\n * @param {BackendGame} game the Game\r\n * @param {Tile[]} rack rack in the form of a simple list of Tile\r\n * @param {function} listener Function that is called with a Move each time\r\n * a new best play is found, or a string containing a progress or error\r\n * message.\r\n * @param {string?} dictionary name of (or path to) dictionary to use,\r\n * defaults to game dictionary\r\n * @return {Promise} Promise that resolves when all best moves have been\r\n * identified\r\n */\r\nfunction findBestPlay(game, rack, listener, dict) {\r\n  report = listener;\r\n  board = game.board;\r\n  return Promise.all([\r\n    loadDictionary(dict)\r\n    .then(dic => dictionary = dic),\r\n\r\n    Edition.load(game.edition)\r\n    .then(ed => edition = ed)\r\n  ])\r\n  .then(() => find(rack));\r\n}\r\n\r\nexport { findBestPlay }\r\n"],"names":["dictionary","edition","crossChecks","board","report","intersection","a","b","filter","l","indexOf","bestScore","isAnchor","col","row","at","isEmpty","cols","rows","computeCrossChecks","available","xChecks","thisCol","push","thisCell","tile","letter","wordAbove","r","wordBelow","wordLeft","c","wordRight","h","hIsWord","length","hasWord","hIsSeq","hasSequence","v","vIsWord","vIsSeq","forward","dcol","drow","rackTiles","tilesPlayed","dNode","wordSoFar","ecol","erow","isEndOfWord","words","score","scorePlay","calculateBonus","Move","placements","t","playedTile","haveBlank","find","isBlank","xc","postLetters","map","shrunkRack","rackTile","Tile","postNodes","post","pop","back","anchorNode","preLetters","unshift","preNodes","pre","shift","rack","sort","reverse","stringify","join","name","assert","Edition","anchored","alphabet","anchorTile","getSequenceRoots","ruck","choices","findAnagrams","Math","round","random","vertical","choice","split","mid","midcol","midrow","end","i","pos","word","bestOpeningPlay","findBestPlay","game","listener","dict","Promise","all","loadDictionary","then","dic","ed"],"sourceRoot":""}