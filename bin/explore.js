/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado
  License MIT. See README.md at the root of this distribution for full copyright
  and license information. Author Crawford Currie http://c-dot.co.uk*/
/* eslint-env node */

/**
 * Command-line program to explore the words encoded in a DAWG
 * generated by {@link module:js/dawg/Compressor}
 * `node js/dawg/explore.js` will tell you how to use it
 * @module
 */
const requirejs = require("requirejs");
const Fs = require("fs").promises;
const getopt = require("posix-getopt");
const Path = require("path");

requirejs.config({
  baseUrl: `${__dirname}/..`,
  paths: {
    common: "js/common",
    server: "js/server",
    platform: "js/server/Platform",
    dawg: "js/dawg",
    game: "js/game"
  }
});

requirejs([
  "dawg/Dictionary", "dawg/Explorer"
], (
  Dictionary, Explorer
) => {

  const DESCRIPTION = [
    "USAGE",
    `\tnode ${Path.relative(".", process.argv[1])} [options] <dictionary> <action> [<words>]`,
    "\nOPTIONS",
    "\t-f, --file <file>- Include words read from file",
    "\nDESCRIPTION",
    "\tExplore a DAWG dictionary, <dictionary> is a file path to a",
    "\t.dict file.",
    "\te.g. `node explore.js dictionaries/CSW2019_English.dict list`",
    "\tThe following actions are available:",
    "\tanagrams",
    "\t\tFind anagrams of the words that use all the letters.",
    "\tarrangements",
    "\t\tFind anagrams of the letters of the words, including",
    "\t\tsub-sequences of the letters e.g. `LED` is a sequence",
    "\t\tof the letters in `WELD`, `WHEELED` and `FLED`",
    "\tsequences",
    "\t\tDetermine if the strings passed are valid sub-sequences of",
    "\t\tany word in the dictionary e.g. 'UZZL' is a valid sub-sequence",
    "\t\tas it is found in 'PUZZLE'. However 'UZZZL' isn't.",
    "\tlist",
    "\t\tList words in the dictionary. If `words` are given, lists all",
    "\t\tdictionary entries that start with one of the words.",
    "\n\tThe default action is `list`.",
    "\tAction names are not case-sensitive." ].join("\n");

  const go_parser = new getopt.BasicParser("f:(file)", process.argv);
  const options = {};
  let option;
  while ((option = go_parser.getopt())) {
    switch (option.option) {
    default: console.debug(DESCRIPTION); process.exit();
    case 'f': options.file = option.optarg; break;
    }
  }

  let i = go_parser.optind();
  const dawg = process.argv[i++];
  if (!dawg) {
    console.error(DESCRIPTION);
    process.exit();
  }
  let action = process.argv[i++];
  if (action) action = action.toLowerCase();  else action ="list";
  const words = [];
  while (i < process.argv.length)
    words.push(process.argv[i++]);

  let getWords;
  if (options.file) {
    getWords = Fs.readFile(this.options.file)
    .then(data => data.toString().split(/\s+/).map(w => words.push(w)));
  } else
    getWords = Promise.resolve(words);

  getWords
  .then(words => words.map(w => w.toUpperCase()))
  .then(words => {
    let dir  = Path.dirname(dawg);
    if (dir === ".") dir = undefined;
    const dict = Path.basename(dawg, ".dict");
    console.log(dict, action, words);
    return Dictionary.load(dict, dir)
    .then(dictionary =>
          Explorer[action].call(null, dictionary, words, console.log));
  });
});
