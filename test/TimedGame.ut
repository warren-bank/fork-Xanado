/* See README.md at the root of this distribution for copyright and
   license information */
/* eslint-env node */

/**
 * Unit tests for behavious specific to timed games
 */
describe("Timed games", function() {

  /* global TestSocket, Platform */
  /* global Edition, Tile, Rack, Player, Game, Move, Turn */
  const TS = require("./TestSupport.js");
  after(() => TS.after());
  before(required => TS.before({
    FileDatabase: "server/FileDatabase",
    Edition: "game/Edition",
    Tile: "game/Tile",
    Rack: "game/Rack",
    Player: "game/Player",
    Game: "game/Game",
    Move: "game/Move",
    Turn: "game/Turn"
  }, required));

  this.timeout(10000);
  
  function UNit() {}

  it('timeout and end game', () => {
    const human1 = new Player({
      name: 'Human 1', key: "human1", isRobot: false});
    const human2 = new Player({
      name: 'Human 2', key: "human2", isRobot: false});

    const game = new Game({
      edition:"Test",
      dictionary:'Oxford_5000',
      //_debug: console.debug,
      noPlayerShuffle: true,
      timerType: Timer.TURN,
      timeAllowed: 1 / 60
    });
    let nextTurn = 0;
    const socket = new TestSocket();
    // Expected turns
    const handle = (turn, event) => {
      //console.log("Turn", nextTurn+1);
      switch (nextTurn++) {
      case 0:
        assert.equal(turn.score, 0);
        assert.equal(turn.type, Turns.TIMED_OUT);
        assert.equal(turn.playerKey, human1.key);
        assert.equal(turn.nextToGoKey, human2.key);
        assert.equal(turn.gameKey, game.key);
        break;
      case 1:
        assert.equal(turn.score, 0);
        assert.equal(turn.type, Turns.TIMED_OUT);
        assert.equal(turn.playerKey, human2.key);
        assert.equal(turn.nextToGoKey, human1.key);
        assert.equal(turn.gameKey, game.key);
        break;
      case 2:
        assert.equal(turn.score, 0);
        assert.equal(turn.type, Turns.TIMED_OUT);
        assert.equal(turn.playerKey, human1.key);
        assert.equal(turn.nextToGoKey, human2.key);
        assert.equal(turn.gameKey, game.key);
        break;
      case 3:
        assert.equal(turn.score, 0);
        assert.equal(turn.type, Turns.TIMED_OUT);
        assert.equal(turn.playerKey, human2.key);
        assert.equal(turn.nextToGoKey, human1.key);
        assert.equal(turn.gameKey, game.key);
        break;
      case 4:
        assert.deepEqual(turn.score, {
          human1: { tiles: -1 }, human2: {tiles: -1 }});
        assert.equal(turn.type, Turns.GAME_ENDED);
        assert.equal(turn.endState, 'All players passed twice');
        assert.equal(turn.gameKey, game.key);
        assert(!turn.nextToGoKey);
        socket.done();
        break;
      default:
        console.error("UNEXPECTED TURN", turn);
        assert.fail("UNEXPECTED TURN");
        socket.done();
      }
    };
    socket.on(Notify.TURN, handle);
    socket.on(Notify.CONNECTIONS, () => {});
    socket.on(Notify.TICK, () => {});
    socket.on('*', (data, event) => {
      console.error("UNEXPECTED EVENT", event);
      assert.fail(event);
    });

    return game.create()
    .then(() => game.onLoad(new FileDatabase("test/temp", "game")))
    .then(game => {
      game.addPlayer(human1);
      human1.rack.addTile(game.letterBag.removeTile({letter:"A"}));
      game.addPlayer(human2);
      human2.rack.addTile(game.letterBag.removeTile({letter:"A"}));
      // we have enough players to kick the game off. We don't need
      // to connect player 2, as the connect() of player1 should
      // kick off play. The players will each timeout twice and
      // the game will finish.
    })
    .then(() => game.connect(socket, human1.key))
    .then(() => socket.wait());
  });

  it('pass and overtime', () => {
    const human1 = new Player({
      name: 'Human 1', key: "human1", isRobot: false});
    const human2 = new Player({
      name: 'Human 2', key: "human2", isRobot: false});

    const game = new Game({
      edition:"Test",
      dictionary:'Oxford_5000',
      //_debug: console.debug,
      noPlayerShuffle: true,
      timerType: Timer.GAME,
      timeAllowed: 1 / 60,
      timePenalty: 60
    });
    let nextTurn = 0;

    const socket = new TestSocket();
    // Expected turns
    const handle = (turn, event) => {
      switch (nextTurn++) {
      case 0:
        assert.equal(turn.score, 0);
        assert.equal(turn.type, Turns.PASSED);
        assert.equal(turn.playerKey, human1.key);
        assert.equal(turn.nextToGoKey, human2.key);
        assert.equal(turn.gameKey, game.key);
        break;
      case 1:
        assert.equal(turn.score, 0);
        assert.equal(turn.type, Turns.PASSED);
        assert.equal(turn.playerKey, human2.key);
        assert.equal(turn.nextToGoKey, human1.key);
        assert.equal(turn.gameKey, game.key);
        break;
      case 2:
        assert.equal(turn.score, 0);
        assert.equal(turn.type, Turns.PASSED);
        assert.equal(turn.playerKey, human1.key);
        assert.equal(turn.nextToGoKey, human2.key);
        assert.equal(turn.gameKey, game.key);
        break;
      case 3:
        assert.equal(turn.score, 0);
        assert.equal(turn.type, Turns.PASSED);
        assert.equal(turn.playerKey, human2.key);
        assert.equal(turn.nextToGoKey, human1.key);
        assert.equal(turn.gameKey, game.key);
        break;
      case 4:
        assert.equal(turn.type, Turns.GAME_ENDED);
        assert.equal(turn.endState, 'All players passed twice');
        assert.equal(turn.score.human1.tiles, -1);
        assert.equal(turn.score.human2.tiles, -1);
        // Human 1 should be over-time by one clock tick, which
        // is 1/60th of a minute.
        assert.equal(turn.score.human1.time, -1);
        // human2 has no time penalty
        assert(!turn.score.human2.time);
        assert.equal(turn.gameKey, game.key);
        assert(!turn.nextToGoKey);
        socket.done();
        break;
      default:
        console.error("UNEXPECTED TURN", turn);
        assert.fail("UNEXPECTED TURN");
        socket.done();
      }
    };
    socket.on(Notify.TURN, handle);

    socket.on(Notify.CONNECTIONS, () => {});

    let onTick;
    function awaitTick() {
      return new Promise(resolve => {
        onTick = resolve;
      });
    }
    socket.on(Notify.TICK, () => {
      if (onTick)
        onTick();
    });
    socket.on('*', (data, event) => {
      console.error("UNEXPECTED EVENT", event);
      assert.fail(event);
    });

    // Players don't time out in a chess clock game, so we have to
    // explicitly pass twice
    return game.create()
    .then(() => game.onLoad(new FileDatabase("test/temp", "game")))
    .then(game => {
      game.addPlayer(human1);
      human1.rack.addTile(game.letterBag.removeTile({letter:"A"}));
      game.addPlayer(human2);
      human2.rack.addTile(game.letterBag.removeTile({letter:"A"}));
    })
    .then(() => game.connect(socket, human1.key))
    .then(() => awaitTick())
    .then(() => game.pass(human1, Turns.PASSED))
    // human 2 plays as soon as possible
    .then(() => game.pass(human2, Turns.PASSED))
    .then(() => awaitTick())
    .then(() => game.pass(human1, Turns.PASSED))
    .then(() => game.pass(human2, Turns.PASSED))
    .then(() => socket.wait());
  });
});

