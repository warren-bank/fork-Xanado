{"version":3,"file":"standalone/findBestPlay.StandaloneGameUI.js","mappings":"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","sources":["webpack://@warren-bank/scrabble/./src/game/findBestPlay.js"],"sourcesContent":["/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\r\n  License MIT. See README.md at the root of this distribution for full copyright\r\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\r\n/* eslint-env amd */\r\n\r\nimport { loadDictionary } from \"./loadDictionary.js\";\r\nimport { Edition } from \"./Edition.js\";\r\nimport { Tile } from \"./Tile.js\";\r\nimport { Move } from \"./Move.js\";\r\n\r\n/** @module */\r\n\r\n/**\r\n * Return a list of the letters that are in both arrays. Does\r\n * not handle blank!\r\n * @param {string[]} a array of letters\r\n * @param {string[]} b array of letters\r\n * @return {string[]} intersection of a and b\r\n * @private\r\n */\r\nfunction intersection(a, b) {\r\n  return a.filter(l => b.indexOf(l) >= 0);\r\n}\r\n\r\n/**\r\n * Dictionary being used to find words\r\n * @private\r\n */\r\nlet dictionary;\r\n\r\n/**\r\n * Edition being played.\r\n * @private\r\n */\r\nlet edition;\r\n\r\n/**\r\n * A matrix where each [col][row] square has two lists, one of\r\n * valid vertical chars and another of valid horizontal chars. The\r\n * [0] lists give the letters that are valid for forming a\r\n * vertical cross word, and the [1] lists give the letters valid\r\n * for creating a horizontal cross word.\r\n * @private\r\n */\r\nlet crossChecks;\r\n\r\n/**\r\n * Shortcut to the board in the game\r\n * @private\r\n */\r\nlet board;\r\n\r\n/**\r\n * The listener function. This takes either a play, or a string\r\n * describing progress. This allows the finder to run in a thread\r\n * and still report back via the main event loop.\r\n * @private\r\n */\r\nlet report;\r\n\r\n/**\r\n * Best score found so far when searching for a move.\r\n * @private\r\n*/\r\nlet bestScore = 0;\r\n\r\n/**\r\n * Unlike Appel and Jacobsen, who anchor plays on empty squares,\r\n * we anchor plays on a square with a tile that has an adjacent\r\n * (horizontal or vertical) non-empty square. This significantly\r\n * reduces the number of anchors that have to be evaluated.\r\n * @param {number} col the square to inspect\r\n * @param {number} row the square to inspect\r\n * @return {boolean} true if this square is a valid anchor\r\n * @private\r\n */\r\nfunction isAnchor(col, row) {\r\n  return !board.at(col, row).isEmpty()\r\n  && (col > 0 && board.at(col - 1, row).isEmpty()\r\n      || col < board.cols - 1 && board.at(col + 1, row).isEmpty()\r\n      || row > 0 && board.at(col, row - 1).isEmpty()\r\n      || row < board.rows - 1 && board.at(col, row + 1).isEmpty());\r\n}\r\n\r\n/**\r\n * Determine which letters can fit in each square and form a valid\r\n * horizontal or vertical cross word. This returns a matrix where\r\n * each [col][row] square has two lists, one of valid vertical\r\n * chars and another of valid horizontal chars. The [0] lists give\r\n * the letters that are valid for forming a vertical cross word,\r\n * and the [1] lists give the letters valid for creating a\r\n * horizontal cross word.  The indices are chosen such that the\r\n * cells can be indexed using the dcol parameter in the other\r\n * functions.\r\n * @param {string[]} available the set of available letters\r\n * @private\r\n */\r\nfunction computeCrossChecks(available) {\r\n  const xChecks = [];\r\n\r\n  for (let col = 0; col < board.cols; col++) {\r\n    const thisCol = [];\r\n    xChecks.push(thisCol);\r\n\r\n    for (let row = 0; row < board.rows; row++) {\r\n      const thisCell = [[], []];\r\n      thisCol[row] = thisCell;\r\n\r\n      if (board.at(col, row).tile) {\r\n        // The cell isn't empty, only this letter is valid.\r\n        thisCell[0].push(board.at(col, row).tile.letter);\r\n        thisCell[1].push(board.at(col, row).tile.letter);\r\n        continue;\r\n      }\r\n\r\n      // Find the words above and below\r\n      let wordAbove = \"\";\r\n      let r = row - 1;\r\n      while (r >= 0 && board.at(col, r).tile) {\r\n        wordAbove = board.at(col, r).tile.letter + wordAbove;\r\n        r--;\r\n      }\r\n\r\n      let wordBelow = \"\";\r\n      r = row + 1;\r\n      while (r < board.rows && board.at(col, r).tile) {\r\n        wordBelow += board.at(col, r).tile.letter;\r\n        r++;\r\n      }\r\n\r\n      // Find the words left and right\r\n      let wordLeft = \"\";\r\n      let c = col - 1;\r\n      while (c >= 0 && board.at(c, row).tile) {\r\n        wordLeft = board.at(c, row).tile.letter + wordLeft;\r\n        c--;\r\n      }\r\n\r\n      let wordRight = \"\";\r\n      c = col + 1;\r\n      while (c != board.cols && board.at(c, row).tile) {\r\n        wordRight += board.at(c, row).tile.letter;\r\n        c++;\r\n      }\r\n\r\n      // Find which (if any) letters form a valid cross word\r\n      for (let letter of available) {\r\n        const h = wordLeft + letter + wordRight;\r\n\r\n        // Is h a complete valid word, or just the letter\r\n        // on its tod?\r\n        const hIsWord = h.length === 1 || dictionary.hasWord(h);\r\n        // Is h a valid complete word, or a legal sub-sequence?\r\n        const hIsSeq = hIsWord || col > 0 && dictionary.hasSequence(h);\r\n\r\n        const v = wordAbove + letter + wordBelow;\r\n        const vIsWord = v.length === 1 || dictionary.hasWord(v);\r\n        const vIsSeq = vIsWord || row > 0 && dictionary.hasSequence(v);\r\n\r\n        if (hIsWord && vIsSeq)\r\n          // A down word is playable with this letter, and\r\n          // there's a valid down sequence involving the\r\n          // letter\r\n          thisCell[0].push(letter);\r\n\r\n        if (vIsWord && hIsSeq)\r\n          // An across word is playable with this letter, and\r\n          // there's a valid across sequence involving the\r\n          // letter\r\n          thisCell[1].push(letter);\r\n      }\r\n    }\r\n  }\r\n\r\n  crossChecks = xChecks;\r\n}\r\n\r\n/**\r\n * Given a position that can have a letter, recursively compute possible\r\n * word plays by extending down/across the board. For each word,\r\n * compute its point value, and update the best score\r\n * accordingly.\r\n *\r\n * @param {number} col index of the current position on the board. This\r\n * is the posiiton of the last character of the word constructed so far.\r\n * @param {number} row index of the current position on the board. This\r\n * is the posiiton of the last character of the word constructed so far.\r\n * @param {number} dcol 1 if the extension direction is across\r\n * @param {number} drow 1 if the extension direction is down\r\n * @param {Tile[]} rackTiles tiles remaining from the user's letter rack.\r\n * @param {number} tilesPlayed number of tiles from the rack already played\r\n * @param {LetterNode} dNode the current LetterNode\r\n * @param {Tile[]} wordSoFar the known letters terminating at the dNode.\r\n * @private\r\n */\r\nfunction forward(col, row,\r\n                 dcol, drow,\r\n                 rackTiles, tilesPlayed,\r\n                 dNode,\r\n                 wordSoFar) {\r\n\r\n  // Square we're hopefully extending into\r\n  const ecol = col + dcol;\r\n  const erow = row + drow;\r\n\r\n  //console.log(`forward '${wordSoFar}' ${col}:${dcol} ${row}:${drow} [${dNode.postLetters.join('')}]`);\r\n\r\n  // Tail recurse; report words as soon as we find them\r\n  // Are we sitting at the end of a scoring word?\r\n  if (dNode.isEndOfWord\r\n      && wordSoFar.length >= 2\r\n      && tilesPlayed > 0\r\n      && (ecol == board.cols || erow == board.rows\r\n          || !board.at(ecol, erow).tile)) {\r\n    const words = [];\r\n    const score =\r\n          board.scorePlay(col, row, dcol, drow,\r\n                               wordSoFar, words)\r\n          + edition.calculateBonus(tilesPlayed);\r\n\r\n    if (score > bestScore) {\r\n      bestScore = score;\r\n      //console.log(drow > 0 ? \"vertical\" : \"horizontal\")\r\n      report(new Move({\r\n        placements: wordSoFar.filter(\r\n          t => !board.at(t.col, t.row).tile),\r\n        words: words,\r\n        score: score\r\n      }));\r\n    }\r\n  }\r\n\r\n  let available; // list of letters that can be extended with\r\n  let playedTile = 0;\r\n\r\n  if (ecol < board.cols && erow < board.rows) {\r\n    // Do we have an empty cell we can extend into?\r\n    if (board.at(ecol, erow).isEmpty()) {\r\n      const haveBlank = rackTiles.find(l => l.isBlank);\r\n      const xc = crossChecks[ecol][erow][dcol];\r\n\r\n      available = intersection(\r\n        dNode.postLetters,\r\n        haveBlank ? xc : intersection(\r\n          rackTiles.map(t => t.letter), xc));\r\n      playedTile = 1;\r\n\r\n    } else\r\n      // Have pre-placed tile\r\n      available = [ board.at(ecol, erow).tile.letter ];\r\n  }\r\n  else // off the board\r\n    available = [];\r\n\r\n  for (let letter of available) {\r\n    let shrunkRack = rackTiles;\r\n    if (playedTile > 0) {\r\n      // Letter played from the rack\r\n      const rackTile = shrunkRack.find(l => l.letter === letter)\r\n            || shrunkRack.find(l => l.isBlank);\r\n      wordSoFar.push(\r\n        new Tile({letter:letter, isBlank:rackTile.isBlank,\r\n                  score:rackTile.score,\r\n                  // Note placement is not used in score computation\r\n                  col: ecol, row: erow}));\r\n      shrunkRack = shrunkRack.filter(t => t !== rackTile);\r\n    } else\r\n      wordSoFar.push(board.at(ecol, erow).tile);\r\n\r\n    for (let post of dNode.postNodes) {\r\n      if (post.letter === letter) {\r\n        forward(ecol, erow,\r\n                     dcol, drow,\r\n                     shrunkRack, tilesPlayed + playedTile,\r\n                     post,\r\n                     wordSoFar);\r\n      }\r\n    }\r\n\r\n    wordSoFar.pop();\r\n  }\r\n}\r\n\r\n/**\r\n * Given a position that may be part of a word, and the letters of\r\n * the word it may be part of, try to back up/left before extending\r\n * down/right.\r\n *\r\n * @param {number} col index of the current position on the board. This\r\n * is the posiiton of the last character of the word constructed so far.\r\n * @param {number} row index of the current position on the board. This\r\n * is the posiiton of the last character of the word constructed so far.\r\n * @param {number} dcol 1 if the extension direction is across\r\n * @param {number} drow 1 if the extension direction is down\r\n * @param {Tile[]} rackTiles tiles remaining from the user's letter rack.\r\n * @param {number} tilesPlayed number of tiles from the rack already played\r\n * @param {LetterNode} anchorNode the DictNode where we started backing up\r\n * @param {LetterNode} dNode the current LetterNode\r\n * @param {Tile[]} wordSoFar the known letters terminating at the dNode.\r\n * @private\r\n */\r\nfunction back(col, row,\r\n              dcol, drow,\r\n              rackTiles, tilesPlayed,\r\n              anchorNode, dNode,\r\n              wordSoFar) {\r\n\r\n  // Square we're hopefully extending into\r\n  const ecol = col - dcol;\r\n  const erow = row - drow;\r\n\r\n  let available; // the set of possible candidate letters\r\n  let playedTile = 0;\r\n\r\n  //console.log(`back '${wordSoFar}' ${col}:${dcol} ${row}:${drow} [${dNode.preLetters.join('')}]`);\r\n\r\n  // Do we have an adjacent empty cell we can back up into?\r\n  if (ecol >= 0 && erow >= 0) {\r\n    if (board.at(ecol, erow).isEmpty()) {\r\n      // Find common letters between the rack, cross checks, and\r\n      // dNode pre.\r\n      const haveBlank = rackTiles.find(l => l.isBlank);\r\n      const xc = crossChecks[ecol][erow][dcol];\r\n\r\n      available =\r\n      intersection(\r\n        dNode.preLetters,\r\n        haveBlank ? xc : intersection(\r\n          rackTiles.map(l => l.letter),  xc));\r\n      playedTile = 1;\r\n    } else\r\n      // Non-empty square, might be able to walk back through it\r\n      available = [ board.at(ecol, erow).tile.letter ];\r\n  }\r\n  else\r\n    // Off the board, nothing available for backing up\r\n    available = [];\r\n\r\n  // Head recurse; longer words are more likely to\r\n  // be high scoring, so want to find them first\r\n  for (let letter of available) {\r\n    let shrunkRack = rackTiles;\r\n    if (playedTile > 0) {\r\n      // Letter came from the rack\r\n      const tile = shrunkRack.find(l => l.letter === letter)\r\n            || shrunkRack.find(l => l.isBlank);\r\n      wordSoFar.unshift(\r\n        new Tile({\r\n          letter: letter, isBlank: tile.isBlank,\r\n          score: tile.score,\r\n          // Note placement is not used in score computation\r\n          col: ecol, row: erow\r\n        }));\r\n      shrunkRack = shrunkRack.filter(t => t !== tile);\r\n    } else\r\n      // Letter already on the board\r\n      wordSoFar.unshift(board.at(ecol, erow).tile);\r\n\r\n    for (let pre of dNode.preNodes) {\r\n      if (pre.letter === letter) {\r\n        back(ecol, erow,\r\n                  dcol, drow,\r\n                  shrunkRack, tilesPlayed + playedTile,\r\n                  anchorNode, pre,\r\n                  wordSoFar);\r\n      }\r\n    }\r\n\r\n    wordSoFar.shift();\r\n  }\r\n\r\n  // If this is the start of a word in the dictionary, and\r\n  // we're at the edge of the board or the prior cell is\r\n  // empty, then we have a valid word start.\r\n  if (dNode.preNodes.length == 0\r\n      && (erow < 0 || ecol < 0 || board.at(ecol, erow).isEmpty())) {\r\n    //console.log(`back word start ${ecol}:${dcol},${erow}:${drow}`);\r\n    // try extending down beyond the anchor, with the letters\r\n    // that we have determined comprise a valid rooted sequence.\r\n    forward(col + dcol * (wordSoFar.length - 1),\r\n                 row + drow * (wordSoFar.length - 1),\r\n                 dcol, drow,\r\n                 rackTiles, tilesPlayed,\r\n                 anchorNode,\r\n                 wordSoFar);\r\n  }\r\n}\r\n\r\n/**\r\n * Special case of the opening move. Find anagrams of the player's\r\n * rack, and find the highest scoring position for each possible word.\r\n * @param {Tile[]} rackTiles tiles on the rack\r\n * @private\r\n */\r\nfunction bestOpeningPlay(rackTiles) {\r\n  const ruck = rackTiles.map(l => l.letter ? l.letter : \" \").join(\"\");\r\n  const choices = dictionary.findAnagrams(ruck);\r\n  //console.debug(\"Choices\", choices);\r\n  // Random whether it is played across or down\r\n  const drow = Math.round(Math.random());\r\n  const dcol = (drow + 1) % 2;\r\n  const vertical = dcol === 0;\r\n  bestScore = 0;\r\n\r\n  for (const choice in choices) {\r\n    // Keep track of the rack and played letters\r\n    const placements = [];\r\n    let shrunkRack = rackTiles;\r\n    for (const c of choice.split(\"\")) {\r\n      const rackTile = shrunkRack.find(t => t.letter === c)\r\n            || shrunkRack.find(t => t.isBlank);\r\n      /* istanbul ignore next */\r\n      assert(rackTile,\r\n             \"Can't do this with the available tiles\");\r\n      placements.push(new Tile({\r\n        letter: c, isBlank: rackTile.isBlank,\r\n        score:rackTile.score\r\n        // Placement is fixed later\r\n      }));\r\n      shrunkRack = shrunkRack.filter(t => t !== rackTile);\r\n    }\r\n\r\n    // Slide the word over the middle to find the optimum\r\n    // position\r\n    const mid = vertical ? board.midcol : board.midrow;\r\n    for (let end = mid;\r\n         end < mid + choice.length;\r\n         end++) {\r\n\r\n      const col = vertical ? mid : end;\r\n      const row = vertical ? end : mid;\r\n      const score =\r\n            board.scorePlay(col, row, dcol, drow, placements)\r\n            + edition.calculateBonus(placements.length);\r\n\r\n      if (score > bestScore) {\r\n        //console.debug(\"Accepted\",choice,\"at\",end,\"for\",score);\r\n        bestScore = score;\r\n        // Fix the placement\r\n        for (let i = 0; i < placements.length; i++) {\r\n          const pos = end - placements.length + i + 1;\r\n          placements[i].col = dcol == 0 ? board.midcol : pos * dcol;\r\n          placements[i].row = drow == 0 ? board.midrow : pos * drow;\r\n        }\r\n        //console.log(drow > 0 ? \"vertical\" : \"horizontal\")\r\n        report(new Move({\r\n          placements: placements,\r\n          words: [{ word: choice, score: score }],\r\n          score: score\r\n        }));\r\n      } else {\r\n        //console.debug(\"Rejected\",choice,\"at\",end,\"for\",score);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Find the best play for the given rack. The results are reported\r\n * using the listener.\r\n * @param {Tile[]} rack rack of tiles to pick from\r\n * @private\r\n */\r\nfunction find(rack) {\r\n  // sort and reverse the rack to make sure high value letters come\r\n  // first and blanks come last. It's not going to make it\r\n  // any faster, but it will abort with a better result if\r\n  // it's going to time out.\r\n  const rackTiles = rack.sort((a, b) => {\r\n    return a.letter < b.letter ? -1  : a.score > b.score ? 1 : 0;\r\n  }).reverse();\r\n\r\n  report(\"Finding best play for rack \"\r\n              + rack.map(t => t.stringify()).join(\",\"));\r\n\r\n  report(`with dictionary ${dictionary.name}`);\r\n  report(`in edition ${edition.name}`);\r\n  report(\"on\\n\" + board.stringify());\r\n\r\n  //assert(dictionary instanceof Dictionary, \"Setup failure\");\r\n  assert(edition instanceof Edition, \"Setup failure\");\r\n\r\n  report(\"Starting findBestPlay computation for \"\r\n              + rackTiles.map(t => t.stringify()).join(\",\")\r\n              + \" on \" + board.stringify());\r\n  bestScore = 0;\r\n\r\n  // Has at least one anchor been explored? If there are\r\n  // no anchors, we need to compute an opening play\r\n  let anchored = false;\r\n  for (let col = 0; col < board.cols; col++) {\r\n    for (let row = 0; row < board.rows; row++) {\r\n      // An anchor is any square that has a tile and has an\r\n      // adjacent blank that can be extended into to form a word\r\n      if (isAnchor(col, row)) {\r\n        if (!anchored) {\r\n          // What letters can be used to form a valid cross\r\n          // word? The whole alphabet if the rack contains a\r\n          // blank, the rack otherwise.\r\n          const available = rackTiles.find(l => l.isBlank)\r\n                ? edition.alphabet\r\n                : (rackTiles.filter(t => !t.isBlank)\r\n                   .map(t => t.letter));\r\n          computeCrossChecks(available);\r\n          anchored = true;\r\n        }\r\n        const anchorTile = board.at(col, row).tile;\r\n        const roots = dictionary.getSequenceRoots(anchorTile.letter);\r\n        for (let anchorNode of roots) {\r\n          // Try and back up then forward through\r\n          // the dictionary to find longer sequences\r\n          // across\r\n          back(\r\n            col, row,\r\n            1, 0,\r\n            rackTiles, 0,\r\n            anchorNode, anchorNode,\r\n            [ anchorTile ]);\r\n\r\n          // down\r\n          back(\r\n            col, row,\r\n            0, 1,\r\n            rackTiles, 0,\r\n            anchorNode, anchorNode,\r\n            [ anchorTile ]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!anchored)\r\n    // No anchors, so this is an opening play.\r\n    bestOpeningPlay(rackTiles);\r\n}\r\n\r\n/**\r\n * Given a user's letter rack, compute the best possible move.\r\n * @param {BackendGame} game the Game\r\n * @param {Tile[]} rack rack in the form of a simple list of Tile\r\n * @param {function} listener Function that is called with a Move each time\r\n * a new best play is found, or a string containing a progress or error\r\n * message.\r\n * @param {string?} dictionary name of (or path to) dictionary to use,\r\n * defaults to game dictionary\r\n * @return {Promise} Promise that resolves when all best moves have been\r\n * identified\r\n */\r\nfunction findBestPlay(game, rack, listener, dict) {\r\n  report = listener;\r\n  board = game.board;\r\n  return Promise.all([\r\n    loadDictionary(dict)\r\n    .then(dic => dictionary = dic),\r\n\r\n    Edition.load(game.edition)\r\n    .then(ed => edition = ed)\r\n  ])\r\n  .then(() => find(rack));\r\n}\r\n\r\nexport { findBestPlay }\r\n"],"names":["dictionary","edition","crossChecks","board","report","intersection","a","b","filter","l","indexOf","bestScore","isAnchor","col","row","at","isEmpty","cols","rows","computeCrossChecks","available","xChecks","thisCol","push","thisCell","tile","letter","wordAbove","r","wordBelow","wordLeft","c","wordRight","h","hIsWord","length","hasWord","hIsSeq","hasSequence","v","vIsWord","vIsSeq","forward","dcol","drow","rackTiles","tilesPlayed","dNode","wordSoFar","ecol","erow","isEndOfWord","words","score","scorePlay","calculateBonus","Move","placements","t","playedTile","haveBlank","find","isBlank","xc","postLetters","map","shrunkRack","rackTile","Tile","postNodes","post","pop","back","anchorNode","preLetters","unshift","preNodes","pre","shift","rack","sort","reverse","stringify","join","name","assert","Edition","anchored","alphabet","anchorTile","getSequenceRoots","ruck","choices","findAnagrams","Math","round","random","vertical","choice","split","mid","midcol","midrow","end","i","pos","word","bestOpeningPlay","findBestPlay","game","listener","dict","Promise","all","loadDictionary","then","dic","ed"],"sourceRoot":""}