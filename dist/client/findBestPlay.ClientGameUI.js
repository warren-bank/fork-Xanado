"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(window["webpackChunk_cdot_xanado"] = window["webpackChunk_cdot_xanado"] || []).push([["findBestPlay"],{

/***/ "./src/game/findBestPlay.js":
/*!**********************************!*\
  !*** ./src/game/findBestPlay.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"findBestPlay\": () => (/* binding */ findBestPlay)\n/* harmony export */ });\n/* harmony import */ var _loadDictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadDictionary.js */ \"./src/game/loadDictionary.js\");\n/* harmony import */ var _Edition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Edition.js */ \"./src/game/Edition.js\");\n/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Tile.js */ \"./src/game/Tile.js\");\n/* harmony import */ var _Move_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Move.js */ \"./src/game/Move.js\");\n/*Copyright (C) 2019-2022 The Xanado Project https://github.com/cdot/Xanado\r\n  License MIT. See README.md at the root of this distribution for full copyright\r\n  and license information. Author Crawford Currie http://c-dot.co.uk*/\r\n/* eslint-env amd */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** @module */\r\n\r\n/**\r\n * Return a list of the letters that are in both arrays. Does\r\n * not handle blank!\r\n * @param {string[]} a array of letters\r\n * @param {string[]} b array of letters\r\n * @return {string[]} intersection of a and b\r\n * @private\r\n */\r\nfunction intersection(a, b) {\r\n  return a.filter(l => b.indexOf(l) >= 0);\r\n}\r\n\r\n/**\r\n * Dictionary being used to find words\r\n * @private\r\n */\r\nlet dictionary;\r\n\r\n/**\r\n * Edition being played.\r\n * @private\r\n */\r\nlet edition;\r\n\r\n/**\r\n * A matrix where each [col][row] square has two lists, one of\r\n * valid vertical chars and another of valid horizontal chars. The\r\n * [0] lists give the letters that are valid for forming a\r\n * vertical cross word, and the [1] lists give the letters valid\r\n * for creating a horizontal cross word.\r\n * @private\r\n */\r\nlet crossChecks;\r\n\r\n/**\r\n * Shortcut to the board in the game\r\n * @private\r\n */\r\nlet board;\r\n\r\n/**\r\n * The listener function. This takes either a play, or a string\r\n * describing progress. This allows the finder to run in a thread\r\n * and still report back via the main event loop.\r\n * @private\r\n */\r\nlet report;\r\n\r\n/**\r\n * Best score found so far when searching for a move.\r\n * @private\r\n*/\r\nlet bestScore = 0;\r\n\r\n/**\r\n * Unlike Appel and Jacobsen, who anchor plays on empty squares,\r\n * we anchor plays on a square with a tile that has an adjacent\r\n * (horizontal or vertical) non-empty square. This significantly\r\n * reduces the number of anchors that have to be evaluated.\r\n * @param {number} col the square to inspect\r\n * @param {number} row the square to inspect\r\n * @return {boolean} true if this square is a valid anchor\r\n * @private\r\n */\r\nfunction isAnchor(col, row) {\r\n  return !board.at(col, row).isEmpty()\r\n  && (col > 0 && board.at(col - 1, row).isEmpty()\r\n      || col < board.cols - 1 && board.at(col + 1, row).isEmpty()\r\n      || row > 0 && board.at(col, row - 1).isEmpty()\r\n      || row < board.rows - 1 && board.at(col, row + 1).isEmpty());\r\n}\r\n\r\n/**\r\n * Determine which letters can fit in each square and form a valid\r\n * horizontal or vertical cross word. This returns a matrix where\r\n * each [col][row] square has two lists, one of valid vertical\r\n * chars and another of valid horizontal chars. The [0] lists give\r\n * the letters that are valid for forming a vertical cross word,\r\n * and the [1] lists give the letters valid for creating a\r\n * horizontal cross word.  The indices are chosen such that the\r\n * cells can be indexed using the dcol parameter in the other\r\n * functions.\r\n * @param {string[]} available the set of available letters\r\n * @private\r\n */\r\nfunction computeCrossChecks(available) {\r\n  const xChecks = [];\r\n\r\n  for (let col = 0; col < board.cols; col++) {\r\n    const thisCol = [];\r\n    xChecks.push(thisCol);\r\n\r\n    for (let row = 0; row < board.rows; row++) {\r\n      const thisCell = [[], []];\r\n      thisCol[row] = thisCell;\r\n\r\n      if (board.at(col, row).tile) {\r\n        // The cell isn't empty, only this letter is valid.\r\n        thisCell[0].push(board.at(col, row).tile.letter);\r\n        thisCell[1].push(board.at(col, row).tile.letter);\r\n        continue;\r\n      }\r\n\r\n      // Find the words above and below\r\n      let wordAbove = \"\";\r\n      let r = row - 1;\r\n      while (r >= 0 && board.at(col, r).tile) {\r\n        wordAbove = board.at(col, r).tile.letter + wordAbove;\r\n        r--;\r\n      }\r\n\r\n      let wordBelow = \"\";\r\n      r = row + 1;\r\n      while (r < board.rows && board.at(col, r).tile) {\r\n        wordBelow += board.at(col, r).tile.letter;\r\n        r++;\r\n      }\r\n\r\n      // Find the words left and right\r\n      let wordLeft = \"\";\r\n      let c = col - 1;\r\n      while (c >= 0 && board.at(c, row).tile) {\r\n        wordLeft = board.at(c, row).tile.letter + wordLeft;\r\n        c--;\r\n      }\r\n\r\n      let wordRight = \"\";\r\n      c = col + 1;\r\n      while (c != board.cols && board.at(c, row).tile) {\r\n        wordRight += board.at(c, row).tile.letter;\r\n        c++;\r\n      }\r\n\r\n      // Find which (if any) letters form a valid cross word\r\n      for (let letter of available) {\r\n        const h = wordLeft + letter + wordRight;\r\n\r\n        // Is h a complete valid word, or just the letter\r\n        // on its tod?\r\n        const hIsWord = h.length === 1 || dictionary.hasWord(h);\r\n        // Is h a valid complete word, or a legal sub-sequence?\r\n        const hIsSeq = hIsWord || col > 0 && dictionary.hasSequence(h);\r\n\r\n        const v = wordAbove + letter + wordBelow;\r\n        const vIsWord = v.length === 1 || dictionary.hasWord(v);\r\n        const vIsSeq = vIsWord || row > 0 && dictionary.hasSequence(v);\r\n\r\n        if (hIsWord && vIsSeq)\r\n          // A down word is playable with this letter, and\r\n          // there's a valid down sequence involving the\r\n          // letter\r\n          thisCell[0].push(letter);\r\n\r\n        if (vIsWord && hIsSeq)\r\n          // An across word is playable with this letter, and\r\n          // there's a valid across sequence involving the\r\n          // letter\r\n          thisCell[1].push(letter);\r\n      }\r\n    }\r\n  }\r\n\r\n  crossChecks = xChecks;\r\n}\r\n\r\n/**\r\n * Given a position that can have a letter, recursively compute possible\r\n * word plays by extending down/across the board. For each word,\r\n * compute its point value, and update the best score\r\n * accordingly.\r\n *\r\n * @param {number} col index of the current position on the board. This\r\n * is the posiiton of the last character of the word constructed so far.\r\n * @param {number} row index of the current position on the board. This\r\n * is the posiiton of the last character of the word constructed so far.\r\n * @param {number} dcol 1 if the extension direction is across\r\n * @param {number} drow 1 if the extension direction is down\r\n * @param {Tile[]} rackTiles tiles remaining from the user's letter rack.\r\n * @param {number} tilesPlayed number of tiles from the rack already played\r\n * @param {LetterNode} dNode the current LetterNode\r\n * @param {Tile[]} wordSoFar the known letters terminating at the dNode.\r\n * @private\r\n */\r\nfunction forward(col, row,\r\n                 dcol, drow,\r\n                 rackTiles, tilesPlayed,\r\n                 dNode,\r\n                 wordSoFar) {\r\n\r\n  // Square we're hopefully extending into\r\n  const ecol = col + dcol;\r\n  const erow = row + drow;\r\n\r\n  //console.log(`forward '${wordSoFar}' ${col}:${dcol} ${row}:${drow} [${dNode.postLetters.join('')}]`);\r\n\r\n  // Tail recurse; report words as soon as we find them\r\n  // Are we sitting at the end of a scoring word?\r\n  if (dNode.isEndOfWord\r\n      && wordSoFar.length >= 2\r\n      && tilesPlayed > 0\r\n      && (ecol == board.cols || erow == board.rows\r\n          || !board.at(ecol, erow).tile)) {\r\n    const words = [];\r\n    const score =\r\n          board.scorePlay(col, row, dcol, drow,\r\n                               wordSoFar, words)\r\n          + edition.calculateBonus(tilesPlayed);\r\n\r\n    if (score > bestScore) {\r\n      bestScore = score;\r\n      //console.log(drow > 0 ? \"vertical\" : \"horizontal\")\r\n      report(new _Move_js__WEBPACK_IMPORTED_MODULE_3__.Move({\r\n        placements: wordSoFar.filter(\r\n          t => !board.at(t.col, t.row).tile),\r\n        words: words,\r\n        score: score\r\n      }));\r\n    }\r\n  }\r\n\r\n  let available; // list of letters that can be extended with\r\n  let playedTile = 0;\r\n\r\n  if (ecol < board.cols && erow < board.rows) {\r\n    // Do we have an empty cell we can extend into?\r\n    if (board.at(ecol, erow).isEmpty()) {\r\n      const haveBlank = rackTiles.find(l => l.isBlank);\r\n      const xc = crossChecks[ecol][erow][dcol];\r\n\r\n      available = intersection(\r\n        dNode.postLetters,\r\n        haveBlank ? xc : intersection(\r\n          rackTiles.map(t => t.letter), xc));\r\n      playedTile = 1;\r\n\r\n    } else\r\n      // Have pre-placed tile\r\n      available = [ board.at(ecol, erow).tile.letter ];\r\n  }\r\n  else // off the board\r\n    available = [];\r\n\r\n  for (let letter of available) {\r\n    let shrunkRack = rackTiles;\r\n    if (playedTile > 0) {\r\n      // Letter played from the rack\r\n      const rackTile = shrunkRack.find(l => l.letter === letter)\r\n            || shrunkRack.find(l => l.isBlank);\r\n      wordSoFar.push(\r\n        new _Tile_js__WEBPACK_IMPORTED_MODULE_2__.Tile({letter:letter, isBlank:rackTile.isBlank,\r\n                  score:rackTile.score,\r\n                  // Note placement is not used in score computation\r\n                  col: ecol, row: erow}));\r\n      shrunkRack = shrunkRack.filter(t => t !== rackTile);\r\n    } else\r\n      wordSoFar.push(board.at(ecol, erow).tile);\r\n\r\n    for (let post of dNode.postNodes) {\r\n      if (post.letter === letter) {\r\n        forward(ecol, erow,\r\n                     dcol, drow,\r\n                     shrunkRack, tilesPlayed + playedTile,\r\n                     post,\r\n                     wordSoFar);\r\n      }\r\n    }\r\n\r\n    wordSoFar.pop();\r\n  }\r\n}\r\n\r\n/**\r\n * Given a position that may be part of a word, and the letters of\r\n * the word it may be part of, try to back up/left before extending\r\n * down/right.\r\n *\r\n * @param {number} col index of the current position on the board. This\r\n * is the posiiton of the last character of the word constructed so far.\r\n * @param {number} row index of the current position on the board. This\r\n * is the posiiton of the last character of the word constructed so far.\r\n * @param {number} dcol 1 if the extension direction is across\r\n * @param {number} drow 1 if the extension direction is down\r\n * @param {Tile[]} rackTiles tiles remaining from the user's letter rack.\r\n * @param {number} tilesPlayed number of tiles from the rack already played\r\n * @param {LetterNode} anchorNode the DictNode where we started backing up\r\n * @param {LetterNode} dNode the current LetterNode\r\n * @param {Tile[]} wordSoFar the known letters terminating at the dNode.\r\n * @private\r\n */\r\nfunction back(col, row,\r\n              dcol, drow,\r\n              rackTiles, tilesPlayed,\r\n              anchorNode, dNode,\r\n              wordSoFar) {\r\n\r\n  // Square we're hopefully extending into\r\n  const ecol = col - dcol;\r\n  const erow = row - drow;\r\n\r\n  let available; // the set of possible candidate letters\r\n  let playedTile = 0;\r\n\r\n  //console.log(`back '${wordSoFar}' ${col}:${dcol} ${row}:${drow} [${dNode.preLetters.join('')}]`);\r\n\r\n  // Do we have an adjacent empty cell we can back up into?\r\n  if (ecol >= 0 && erow >= 0) {\r\n    if (board.at(ecol, erow).isEmpty()) {\r\n      // Find common letters between the rack, cross checks, and\r\n      // dNode pre.\r\n      const haveBlank = rackTiles.find(l => l.isBlank);\r\n      const xc = crossChecks[ecol][erow][dcol];\r\n\r\n      available =\r\n      intersection(\r\n        dNode.preLetters,\r\n        haveBlank ? xc : intersection(\r\n          rackTiles.map(l => l.letter),  xc));\r\n      playedTile = 1;\r\n    } else\r\n      // Non-empty square, might be able to walk back through it\r\n      available = [ board.at(ecol, erow).tile.letter ];\r\n  }\r\n  else\r\n    // Off the board, nothing available for backing up\r\n    available = [];\r\n\r\n  // Head recurse; longer words are more likely to\r\n  // be high scoring, so want to find them first\r\n  for (let letter of available) {\r\n    let shrunkRack = rackTiles;\r\n    if (playedTile > 0) {\r\n      // Letter came from the rack\r\n      const tile = shrunkRack.find(l => l.letter === letter)\r\n            || shrunkRack.find(l => l.isBlank);\r\n      wordSoFar.unshift(\r\n        new _Tile_js__WEBPACK_IMPORTED_MODULE_2__.Tile({\r\n          letter: letter, isBlank: tile.isBlank,\r\n          score: tile.score,\r\n          // Note placement is not used in score computation\r\n          col: ecol, row: erow\r\n        }));\r\n      shrunkRack = shrunkRack.filter(t => t !== tile);\r\n    } else\r\n      // Letter already on the board\r\n      wordSoFar.unshift(board.at(ecol, erow).tile);\r\n\r\n    for (let pre of dNode.preNodes) {\r\n      if (pre.letter === letter) {\r\n        back(ecol, erow,\r\n                  dcol, drow,\r\n                  shrunkRack, tilesPlayed + playedTile,\r\n                  anchorNode, pre,\r\n                  wordSoFar);\r\n      }\r\n    }\r\n\r\n    wordSoFar.shift();\r\n  }\r\n\r\n  // If this is the start of a word in the dictionary, and\r\n  // we're at the edge of the board or the prior cell is\r\n  // empty, then we have a valid word start.\r\n  if (dNode.preNodes.length == 0\r\n      && (erow < 0 || ecol < 0 || board.at(ecol, erow).isEmpty())) {\r\n    //console.log(`back word start ${ecol}:${dcol},${erow}:${drow}`);\r\n    // try extending down beyond the anchor, with the letters\r\n    // that we have determined comprise a valid rooted sequence.\r\n    forward(col + dcol * (wordSoFar.length - 1),\r\n                 row + drow * (wordSoFar.length - 1),\r\n                 dcol, drow,\r\n                 rackTiles, tilesPlayed,\r\n                 anchorNode,\r\n                 wordSoFar);\r\n  }\r\n}\r\n\r\n/**\r\n * Special case of the opening move. Find anagrams of the player's\r\n * rack, and find the highest scoring position for each possible word.\r\n * @param {Tile[]} rackTiles tiles on the rack\r\n * @private\r\n */\r\nfunction bestOpeningPlay(rackTiles) {\r\n  const ruck = rackTiles.map(l => l.letter ? l.letter : \" \").join(\"\");\r\n  const choices = dictionary.findAnagrams(ruck);\r\n  //console.debug(\"Choices\", choices);\r\n  // Random whether it is played across or down\r\n  const drow = Math.round(Math.random());\r\n  const dcol = (drow + 1) % 2;\r\n  const vertical = dcol === 0;\r\n  bestScore = 0;\r\n\r\n  for (const choice in choices) {\r\n    // Keep track of the rack and played letters\r\n    const placements = [];\r\n    let shrunkRack = rackTiles;\r\n    for (const c of choice.split(\"\")) {\r\n      const rackTile = shrunkRack.find(t => t.letter === c)\r\n            || shrunkRack.find(t => t.isBlank);\r\n      /* istanbul ignore next */\r\n      assert(rackTile,\r\n             \"Can't do this with the available tiles\");\r\n      placements.push(new _Tile_js__WEBPACK_IMPORTED_MODULE_2__.Tile({\r\n        letter: c, isBlank: rackTile.isBlank,\r\n        score:rackTile.score\r\n        // Placement is fixed later\r\n      }));\r\n      shrunkRack = shrunkRack.filter(t => t !== rackTile);\r\n    }\r\n\r\n    // Slide the word over the middle to find the optimum\r\n    // position\r\n    const mid = vertical ? board.midcol : board.midrow;\r\n    for (let end = mid;\r\n         end < mid + choice.length;\r\n         end++) {\r\n\r\n      const col = vertical ? mid : end;\r\n      const row = vertical ? end : mid;\r\n      const score =\r\n            board.scorePlay(col, row, dcol, drow, placements)\r\n            + edition.calculateBonus(placements.length);\r\n\r\n      if (score > bestScore) {\r\n        //console.debug(\"Accepted\",choice,\"at\",end,\"for\",score);\r\n        bestScore = score;\r\n        // Fix the placement\r\n        for (let i = 0; i < placements.length; i++) {\r\n          const pos = end - placements.length + i + 1;\r\n          placements[i].col = dcol == 0 ? board.midcol : pos * dcol;\r\n          placements[i].row = drow == 0 ? board.midrow : pos * drow;\r\n        }\r\n        //console.log(drow > 0 ? \"vertical\" : \"horizontal\")\r\n        report(new _Move_js__WEBPACK_IMPORTED_MODULE_3__.Move({\r\n          placements: placements,\r\n          words: [{ word: choice, score: score }],\r\n          score: score\r\n        }));\r\n      } else {\r\n        //console.debug(\"Rejected\",choice,\"at\",end,\"for\",score);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Find the best play for the given rack. The results are reported\r\n * using the listener.\r\n * @param {Tile[]} rack rack of tiles to pick from\r\n * @private\r\n */\r\nfunction find(rack) {\r\n  // sort and reverse the rack to make sure high value letters come\r\n  // first and blanks come last. It's not going to make it\r\n  // any faster, but it will abort with a better result if\r\n  // it's going to time out.\r\n  const rackTiles = rack.sort((a, b) => {\r\n    return a.letter < b.letter ? -1  : a.score > b.score ? 1 : 0;\r\n  }).reverse();\r\n\r\n  report(\"Finding best play for rack \"\r\n              + rack.map(t => t.stringify()).join(\",\"));\r\n\r\n  report(`with dictionary ${dictionary.name}`);\r\n  report(`in edition ${edition.name}`);\r\n  report(\"on\\n\" + board.stringify());\r\n\r\n  //assert(dictionary instanceof Dictionary, \"Setup failure\");\r\n  assert(edition instanceof _Edition_js__WEBPACK_IMPORTED_MODULE_1__.Edition, \"Setup failure\");\r\n\r\n  report(\"Starting findBestPlay computation for \"\r\n              + rackTiles.map(t => t.stringify()).join(\",\")\r\n              + \" on \" + board.stringify());\r\n  bestScore = 0;\r\n\r\n  // Has at least one anchor been explored? If there are\r\n  // no anchors, we need to compute an opening play\r\n  let anchored = false;\r\n  for (let col = 0; col < board.cols; col++) {\r\n    for (let row = 0; row < board.rows; row++) {\r\n      // An anchor is any square that has a tile and has an\r\n      // adjacent blank that can be extended into to form a word\r\n      if (isAnchor(col, row)) {\r\n        if (!anchored) {\r\n          // What letters can be used to form a valid cross\r\n          // word? The whole alphabet if the rack contains a\r\n          // blank, the rack otherwise.\r\n          const available = rackTiles.find(l => l.isBlank)\r\n                ? edition.alphabet\r\n                : (rackTiles.filter(t => !t.isBlank)\r\n                   .map(t => t.letter));\r\n          computeCrossChecks(available);\r\n          anchored = true;\r\n        }\r\n        const anchorTile = board.at(col, row).tile;\r\n        const roots = dictionary.getSequenceRoots(anchorTile.letter);\r\n        for (let anchorNode of roots) {\r\n          // Try and back up then forward through\r\n          // the dictionary to find longer sequences\r\n          // across\r\n          back(\r\n            col, row,\r\n            1, 0,\r\n            rackTiles, 0,\r\n            anchorNode, anchorNode,\r\n            [ anchorTile ]);\r\n\r\n          // down\r\n          back(\r\n            col, row,\r\n            0, 1,\r\n            rackTiles, 0,\r\n            anchorNode, anchorNode,\r\n            [ anchorTile ]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!anchored)\r\n    // No anchors, so this is an opening play.\r\n    bestOpeningPlay(rackTiles);\r\n}\r\n\r\n/**\r\n * Given a user's letter rack, compute the best possible move.\r\n * @param {BackendGame} game the Game\r\n * @param {Tile[]} rack rack in the form of a simple list of Tile\r\n * @param {function} listener Function that is called with a Move each time\r\n * a new best play is found, or a string containing a progress or error\r\n * message.\r\n * @param {string?} dictionary name of (or path to) dictionary to use,\r\n * defaults to game dictionary\r\n * @return {Promise} Promise that resolves when all best moves have been\r\n * identified\r\n */\r\nfunction findBestPlay(game, rack, listener, dict) {\r\n  report = listener;\r\n  board = game.board;\r\n  return Promise.all([\r\n    (0,_loadDictionary_js__WEBPACK_IMPORTED_MODULE_0__.loadDictionary)(dict)\r\n    .then(dic => dictionary = dic),\r\n\r\n    _Edition_js__WEBPACK_IMPORTED_MODULE_1__.Edition.load(game.edition)\r\n    .then(ed => edition = ed)\r\n  ])\r\n  .then(() => find(rack));\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://@cdot/xanado/./src/game/findBestPlay.js?");

/***/ })

}]);